## これ is 何
今回のチーム開発で、GoでAPIサーバーを構築する際に採用したいアーキテクチャを軽く考えてみました。

よくあるDDD+オニオンアーキテクチャ（なんちゃって）
という感じです。  
[参考にしている依存関係の図](https://storage.googleapis.com/zenn-user-upload/0da2579f4501-20221031.png)

## 補足
ドメインが複雑な訳ではないので、特にDDDの思想に縛られなくて良いと思います。

どのようなデザインパターンを扱うにあたっても、どのみち最低でも以下の三つのモデルに切り分けることになると思います。

・クライアントに近いモデル（クライアントが必要とするモデル）  
・DBのテーブルに対応するモデル  
・ロジックでこねくり回す、中心となるモデル

これらを実現する上で相性が良さそうなのがDDDっぽいデザインパターンだったので採用しているだけです！
思想はそんなに関係ないです。

## ポイント

### パッケージ
・domain/entity  
モデルの構造体を置く。  
ドメインロジックもここに置く。

・domain/repository  
データ取得を隠蔽する。（取得先がDBなのかAPIなのか詳細を隠す）  
interfaceを定義する

・handler  
JSONをパースする。  
プレゼンテーション層にふさわしいバリデーションを行う。（文字列がセットされているか、など）  
controller

・usecase  
entityやrepositoryを使って、ドメインロジックを実現する。

・infra
repositoryの実装を書く。  
DB接続やAPIを叩きに行く。

・registry  
controllerにrepositoryをDIするために用意しているだけなのでいらないかもです。


### controllerのメソッドにregistoryをDIできるようにしています。

これはmockのregistoryを渡すことでhandler層をテスタブルにしたいというお気持ちと、infraに直接依存させたくないためDIしています。

しかし、handler層に単体テストを書くことはあまり効果的ではないと考えています。
理由としては、handler層の責務はクライアントから受け取ったJSONをパースして、値がセットされているか？などの最も簡易的なバリデーションだけを行い、usecaseを呼び出し、値をJSONに変換してクライアントに返すことです。
usecaseはそれ自体の単体テストを書くべきですし、その他の処理はライブラリをテストすることになります（JSONのパース）
また、簡単なバリエーションはそれ自体をコンストラクタ関数に切り出して、単体テストを書くべきです。

上記の理由からhandler層にテストを書く必要はあまりないので、直接infraに依存して、repositoryを生成してもよいかなぁとも思っています。
